You are coding an Express + TypeScript API endpoint:

Goal
- Implement POST /v-dem/analysis/relationships/explain.
- It builds a robust LLM prompt that explains the relationship between two V‑Dem indices for a given country.
- It pulls index metadata (name, question, definition) from definitions.json.
- It pulls the correlation coefficient between the two indices from correlations.parquet.
- It returns the constructed prompt as JSON. If execute=true, also call OpenAI and return the model’s explanation.

Constraints
- Code in TypeScript.
- Use OpenAI Node SDK v1.x.
- Read definitions.json once and cache in-memory (by index_code).
- Query correlations.parquet using DuckDB (preferred) and cache the DB connection.
- Strong input validation and clear error responses.
- Clean separation of concerns (loader, query, prompt builder, handler).

Environment/config
- Env vars (with defaults):
  - RESPONSE_JSON_PATH = ./definitions.json
  - CORRELATIONS_PARQUET_PATH = ./correlations.parquet
  - OPENAI_API_KEY = (required if execute=true)
  - OPENAI_MODEL = gpt-4o (default)
- Add minimal logging.

Request/response
- Route: POST /v-dem/analysis/relationships/explain
- Request body (JSON):
  {
    "indexA": "v2x_freexp_altinf",          // required, string
    "indexB": "v2x_partipdem",              // required, string
    "country": "SWE",                       // required, ISO3 or canonical name
    "yearRange": { "start": 1990, "end": 2020 }, // optional
    "execute": false                        // optional; if true, call OpenAI and include explanation
  }
- Response 200:
  {
    "prompt": "…full prompt string…",
    "context": {
      "indexA": { "index_code","name","question","definition" },
      "indexB": { "index_code","name","question","definition" },
      "country": "SWE",
      "yearRange": { "start":1990,"end":2020 } | null,
      "correlation": { "r": -0.42, "n": 31, "method": "Pearson", "yearsCovered": [1990,2020] }
    },
    "model": "gpt-4o",
    "explanation": "…LLM output…" // only when execute=true
  }
- Errors:
  - 400: invalid body (missing/invalid fields)
  - 404: index metadata not found
  - 404: correlation not found for provided filters
  - 500: internal errors (read/parquet/openai)

Data sources
- definitions.json: JSON array of objects with keys: index_code, name, question, definition.
- correlations.parquet: columns (example; adapt to actual schema): index_code_a, index_code_b, country (ISO3), start_year, end_year, r (float), n (int), method (string). Multiple rows may exist for different year windows. If yearRange provided, prefer the row that best matches (max overlap). Else, choose the row with the widest coverage (max n, then widest window).

Tech choices
- Validation: zod (preferred) or express-validator.
- Parquet query: duckdb (npm: duckdb). Create a single persistent connection.
- OpenAI: npm openai v1.x. Example: 
  import OpenAI from "openai";
  const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

Types
- type IndexMeta = { index_code: string; name: string; question: string; definition: string };
- type ExplainRequest = {
    indexA: string; indexB: string; country: string;
    yearRange?: { start: number; end: number };
    execute?: boolean;
  };
- type Correlation = { r: number; n?: number; method?: string; start_year?: number; end_year?: number };
- type ExplainResponse = {
    prompt: string;
    context: {
      indexA: IndexMeta; indexB: IndexMeta; country: string;
      yearRange: { start: number; end: number } | null;
      correlation: { r: number; n?: number; method?: string; yearsCovered?: [number, number] } | null;
    };
    model: string;
    explanation?: string;
  };

Implementation outline
1) Module-level singletons:
   - const indexMap = await loadIndexMeta(RESPONSE_JSON_PATH) // Map<string, IndexMeta>
   - const db = await initDuckDB(); // memory-cached connection
2) Helpers:
   - async function loadIndexMeta(path: string): Promise<Map<string, IndexMeta>>
     - Read JSON, validate, normalize whitespace, key by lowercase index_code.
   - function getIndexMetaSafe(code: string): IndexMeta | null
   - async function getCorrelation(params: {
       indexA: string; indexB: string; country: string;
       yearRange?: { start: number; end: number };
     }): Promise<Correlation | null>
     - Normalize codes; query duckdb:
       - Ensure symmetrical lookup: (a,b) or (b,a)
       - If yearRange given, compute overlap and pick best match by max overlap then highest n
       - Else, pick by highest n, then widest (end_year - start_year)
   - function buildExplainPrompt(args: {
       metaA: IndexMeta; metaB: IndexMeta; country: string;
       correlation: Correlation | null; yearRange?: { start:number; end:number }
     }): string
     - Compose a system+user style text (single string) that:
       - Names the indices and country
       - Includes r (and n/method/years window if available)
       - Quotes index names + questions + definitions
       - Instructions:
         • Explain relationship and plausible mechanisms; discuss direction/sign of r
         • Mention potential confounders and measurement caveats
         • Avoid causal claims; correlation != causation
         • Keep it country-specific; avoid invented facts; only use provided context
         • Target 200–300 words; structure with:
           - Summary (2–3 sentences)
           - Details (bullet points, 3–6 bullets)
           - Caveats (2–3 bullets)
         • If metadata is missing, explicitly state which pieces are unknown
3) Handler:
   - Validate body with zod
   - Lookup metaA/metaB; 404 if missing
   - Query correlation; 404 if not found (or allow null and still build prompt—choose strict 404 by default)
   - Build prompt
   - If execute=true:
     - Require OPENAI_API_KEY; call client.chat.completions.create({
         model, messages: [{ role: "user", content: prompt }], temperature: 0.2, max_tokens: 800
       });
     - Return explanation in response
   - Else, return prompt and context only
4) Wire into router and export.

Edge cases
- Trim and lowercase index codes for lookup, but preserve original casing in output.
- Accept country as ISO3 or name; for parquet filtering, require ISO3; consider a simple map/normalize (out of scope if not provided).
- Handle swapped index order in parquet.
- When multiple correlations remain equally good, pick the one with the most recent end_year.

Acceptance criteria
- POST /v-dem/analysis/relationships/explain with valid inputs returns 200 and JSON containing prompt + context.
- With execute=true and valid OpenAI key, returns explanation string.
- 404 when unknown index_code or no correlation found for filters.
- No blocking I/O on each request for definitions.json (uses cache).
- Unit-level utility functions are typed and tested minimally (where feasible).

Deliverables
- Route implementation file (e.g., src/routes/vdemExplain.ts) and router registration.
- Utilities: src/services/indexMeta.ts, src/services/correlations.ts, src/services/openai.ts, src/services/prompt.ts (optional modular split).
- Types: src/types/vdem.ts
- Basic tests or a test harness stub.
- README snippet for env vars and example curl.

Example prompt content (built by buildExplainPrompt)
- Header: “Explain relationship between ‘Academic Freedom Index (v2xca_academ)’ and ‘Participatory democracy index (v2x_partipdem)’ in SWE”
- Context block:
  - r = 0.62 (Pearson), n=31, years=1990–2020
  - Definitions and questions for both indices (quoted verbatim)
- Instructions block with Summary/Details/Caveats structure, no hallucinations, no causal claims.

Additional information: I have added definitions.json in the src folder